from dpipe_configs.torch import *
from .network import *

import numpy as np
from sklearn.metrics import accuracy_score, recall_score, precision_score
from dpipe.torch import inference_step
from dpipe.train import ConsoleLogger
from dpipe.batch_iter import Infinite, load_by_random_id
from dpipe.split import train_val_test_split
from dpipe.im.preprocessing import normalize

from torchvision.datasets.mnist import MNIST

dataset = MNIST('~/tests/MNIST', download=True)
ids = range(len(dataset))

load_x = lambda i: normalize(np.array(dataset.data[int(i)], 'float32')[None])
load_y = lambda i: dataset.targets[int(i)]

lr = 1e-3
n_epochs = 10
batch_iter = Infinite(
    load_by_random_id(load_x, load_y, ids=ids),
    batches_per_epoch=20, batch_size=500
)


def predict(image):
    return inference_step(image[None], architecture=architecture, activation=activation).argmax()


val_metrics = metrics = {
    'accuracy': accuracy_score,
    'precision': partial(precision_score, average='weighted'),
    'recall': partial(recall_score, average='weighted'),
}

run_experiment = (
    run_train_predict,
    commands.evaluate_aggregated_metrics(load_y, metrics, test_predictions_path, 'test_metrics')
)
validate_step = None

# take 2 first folds
split = train_val_test_split(ids, val_size=1, n_splits=20)[:2]
logger = ConsoleLogger()
